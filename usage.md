# mongofile:usage:/how/to/use/this.lib
=======
This library use a different approach to accessing files and is more Java centric than the GridFS implementation is in the mongo-java-driver. Rather than having to cast the file objects, I made the decision to prefer static compile time type-checking and simplified object APIs over what is currently available from GridFS(2.11). 

The reading, and writing functions are separated from the main store code to keep usage more simple for the most common read and writes. 

Gzip compression is automatically detected based on media type of the file unless turned off in the configuration. Most media types will be stored compressed to save bytes ( even whole chunks ) in the store. This is handled transparently and the user does not need to know when compression is involved.

Optional encryption is also supported by providing the Encryption class to perform the encryption and decryption of file chunks while storing and reading the file. The use of encryption will automatically detected from the storage format store with the file, however the correct decryption algorithm is required to be provided with the configuration in order to succesfully. 


Also TTL expiration ( deletion ) will allow for usage as a cache to store objects that have a finite lifespan.

## URL 
A mongofile URL protocol has also been implemented to allow a single string to to represent all the info need to fetch the file back as well as give some metadata to the user wihtout having to query the store for basic metadata. Several examples look like this 

```
mongofile:/home/myself/foo/filename.zip?52fb1e7b36707d6d13ebfda9#application/zip
mongofile:gz:/mypath/fileName.pdf?52fb1e7b36707d6d13ebfda9#application/pdf
```

For the second example above, the parts of the URL represent :

| Part | Meaning |
| ----:|:--- |
| mongofile | the protocol |
| gz | compression was used to save space storing the file |
| /mypath/fileName.pdf | the file path and name |
| 52fb1e7b36707d6d13ebfda9 | a UUID id generated by the MongoDB driver for this object |
| application/pdf | the media type for the data |

## The API
THe API for this library has changed a bit from the 0.7.x version to allow for migration to the new objects that are present in the upcoming Mongo-Java-Driver 3.0.x. This library now uses surrogate objects to conform it to the same objects used by the 3.0.x driver so that when the 3.0.x driver is released, this library will be ready to work with it. I plan for this library to go 1.0.x shortly after the 3.0.x driver is released.

# Stand up a MongoFileStore

## MongoClient and the database 
Configure the connection to the MongoDB server and database in whatever fashion is available to you. Consult the MongoClient class from the driver for more Info.

The database object below is a traditional com.mongodb.DB object.

## Configuration
```Java
MongoFileStoreConfig config = MongoFileStoreConfig.builder()// start builder
        .bucket(bucket) // <bucket>.files and <bucket>.chunks
        .chunkSize(ChunkSize.medium_256K) // default
        .enableCompression(true) //  default
        .enableEncryption(null) // must be null if compression is enabled
        .writeConcern(WriteConcern.SAFE) // default
        .readPreference(ReadPreference.primary()) // default
        .build(); // generate the configuration

MongoFileStore store = new MongoFileStore(database, config);
```
Keep the store handy, it is the core of all operations with file stored in MongoFS. If you are using Spring, use Java or XML configuration to make it a Spring bean and inject this object where you need to access files.

> NOTE : Compression and encryption are *not* allowed to be used at the same time. This could cause a severe expansion of the storage size on disk if used together, choose one or the other on a per "bucket" basis. 

## GridFS compatiable configuration
```Java
MongoFileStoreConfig config = MongoFileStoreConfig.builder().gridFSCompatible('test');

MongoFileStore store = new MongoFileStore(database, config);

```

## File expiration
A file expriation timestamp can be placed on the file if storage in the file store is temporary. This expiration utilizes the MongoDB TTL index feature so the removal of file is dependant on the server side background process being enabled on the server. Expired files still in the file store will still be served up if requested before the server process can remove the files and chunks.

```Java
// When a file is created 
Date expiresAt = TimeMachine.from(0).forward(3).days().inTime();

MongoFileWriter writer = store.createNew(filename, mediaType, expiresAt, true);
writer.write(new ByteArrayInputStream(LoremIpsum.LOREM_IPSUM.getBytes()));

// after a file is created
MongoFile first = store.find("/foo/bar.txt").next();
store.expireFile(first,  expiresAt);

```

> NOTE : A simple Date manipulation DSL exists in the library called TimeMachine. It has its limits but should be sufficient for most needs. You can also combine different units of measure ( days, hours, minutes, ...) to come up with some unique situations. For example : 

```Java 
TimeMachine.now().backward(2).days().forward(5).hours().backward(10).minutes().inTime();
```



# File I/O

##Writing files into the store

```Java
MongoFileWriter writer = store.createNew("README.md", "text/plain", true);
writer.write(new ByteArrayInputStream(LOREM_IPSUM.getBytes()));
MongoFile file = writer.getMongoFile();
URL url = file.getURL();

System.out.println(url);
```
would print the following to stdout

```
mongofile:gz:README.md?52fb1e7b36707d6d13ebfda9#text/plain
```
where the parts represent : 

| Part | Meaning |
| ----:|:--- |
| mongofile | the protocol |
| gz | compression was used to save space storing the file |
| README.md | the file path and name |
| 52fb1e7b36707d6d13ebfda9 | a UUID id generated by the MongoDB driver for this document |
| text/plain | the media type for the data |

Store the url string how you like and use it to fetch the file back from the store when its needed. 

> REMEMBER : Filenames are *NOT* unique in the system, you can have many files with the same path and file name.


## Finding and reading files
Using a stored URL string 

```Java
MongoFileUrl url = MongoFileUrl.construct("mongofile:gz:README.md?52fb1e7b36707d6d13ebfda9#text/plain");
MongoFile mongoFile = store.getFile(url); // lookup the file by its url
  
ByteArrayOutputStream out = new ByteArrayOutputStream(32 * 1024);
store.read(mongoFile, out, true); // true == flush output stream when done

String fileText = out.toString();       
```

You can still read files by file name from the store as well.

```Java
ByteArrayOutputStream out = new ByteArrayOutputStream(32 * 1024);

MongoFileCursor cursor = store.find("/foo/bar1.txt");
int count = 0;
for (MongoFile mongoFile : cursor) {
    ++count;
    assertNotNull(mongoFile.getURL());
    assertEquals("/foo/bar1.txt", mongoFile.getFilename());
    InputStream in = new MongoFileReader(store, mongoFile).getInputStream();
    new BytesCopier(in, out).transfer(true); // append more than one file together
}
assertEquals(2, count);
assertEquals(LoremIpsum.LOREM_IPSUM.length() * 2, out.toString().length());
```


## Removing files from the store

```Java
String storedSomewhereElse = "mongofile:gz:README.md?52fb1e7b36707d6d13ebfda9#text/plain";

MongoFileUrl url = MongoFileUrl.construct(storedSomewhereElse);
store.remove(url);
```

You can also asynchronously delete files if the store is configured for that, this feature utilizes the file expiration feature to delete the files, so  



##Where to find more
Check out the integration tests in the source code, there are many examples of how to do things with mongoFS. I am trying to all of the features in the library with an integration test.


